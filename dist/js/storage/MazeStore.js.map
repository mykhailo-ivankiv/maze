{"version":3,"sources":["js/storage/MazeStore.js"],"names":[],"mappings":"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","file":"js/storage/MazeStore.js","sourcesContent":["import Reflux from \"reflux\";\nimport Immutable from \"immutable\";\nimport {getFirstUniqueInt, getRandomInt} from \"utils/helper\";\n\n/**\n * Eller's Algorithm\n * RU - http://habrahabr.ru/post/176671/\n * EN - http://www.neocomputer.org/projects/eller.html\n */\nfunction *renderMaze (mazeWidth = 15, mazeLength = 15) {\n\n  let startSet = Array\n                  .apply(null, {length: mazeWidth})\n                  .map((el, i)=> ({ top: false, left: false, bottom: false, right: false, value: i}));\n  let result = [];\n\n  for (let rowIndex=0; rowIndex < mazeLength; rowIndex += 1) {\n    let lengthOfSubset = 1;\n\n    startSet\n      .map((cell, cellIndex) => {\n        if (startSet[cellIndex + 1] !== undefined && startSet[cellIndex + 1].value === cell.value) {\n          cell.right = true;\n        } else if (Math.random() < 0.5 && startSet[cellIndex + 1] !== undefined) {\n          startSet[cellIndex + 1].value = cell.value;\n        } else {\n          cell.right = true;\n        }\n\n        cell.top = rowIndex === 0;\n        cell.left = cellIndex === 0;\n        cell.right = (cellIndex === (mazeWidth - 1)) || cell.right;\n\n        return cell;\n      })\n      .map((el, k) => {\n        if (startSet[k + 1] !== undefined && startSet[k + 1].value === el.value) {\n          lengthOfSubset += 1;\n        } else {\n          let doorCount = getRandomInt(1, lengthOfSubset);\n\n          for (let f = k; f > k - lengthOfSubset; f -= 1) {\n            if (doorCount === 0) {\n              startSet[f].bottom = true;\n            } else if (doorCount === f - k + lengthOfSubset) {\n              doorCount -= 1;\n              startSet[f].bottom = false;\n            } else if (Math.random() > 0.5) {\n              startSet[f].bottom = true;\n            } else {\n              doorCount -= 1;\n              startSet[f].bottom = false;\n            }\n          }\n\n          lengthOfSubset = 1;\n        }\n      });\n\n    result.push(Immutable.fromJS(startSet).toJS());\n\n    yield(result);\n\n    startSet = Immutable.fromJS(startSet).toJS()\n      .map((el,index, array) => {\n        if (el.bottom) {\n          el.value = getFirstUniqueInt(array.map(el => el.value));\n        }\n        el.bottom = false;\n        el.right = false;\n        return el;\n      })\n\n  }\n\n  result[result.length - 1]\n    .forEach((el, index, array)=>{\n      el.bottom = true;\n\n      if(array[index+1]) {\n        console.log(el.value, array[index+1].value, array.map(el=>el.value));\n      }\n\n      if (array[index+1] && el.value !== array[index+1].value) {\n        el.right = false;\n        array[index+1].value = el.value;\n      }\n\n    });\n\n  return result;\n}\n\n\nexport var MazeActions = Reflux.createActions([\n  \"goToNextRow\",\n  \"goToPrevRow\"\n]);\n\nvar mazeGenerator = renderMaze();\nvar maze = mazeGenerator.next().value;\n\nexport var MazeStore = Reflux.createStore({\n  pointer : 0,\n  listenables: MazeActions,\n\n  onGoToNextRow() {\n    this.pointer += 1;\n    if (maze.length < this.pointer) {maze = mazeGenerator.next().value;}\n    this.trigger();\n  },\n\n  onGoToPrevRow () {\n    this.pointer -= 1;\n    this.trigger();\n  },\n\n  getMaze () {\n    return maze.slice(0, this.pointer);\n  },\n\n  getTotalProgress () {\n    return maze.length;\n  },\n\n  getActiveProgress () {\n    return this.pointer;\n  }\n});"],"sourceRoot":"/source/"}